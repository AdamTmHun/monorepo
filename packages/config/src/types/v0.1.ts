/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface InlangConfig01 {
    /**
     * A link to the JSON schema.
     *
     * Go to https://github.com/inlang/inlang/tree/main/packages/config/src/schemas to see a list of all schemas.
     *
     * Using a schema enables auto-complete and linting in most IDE's via https://json-schema.org/. Furthermore, defining a version of the config file allows for changes down the line with auto-migration scripts.
     */
    $schema: string;
    /**
     * The file format of the local translation files.
     *
     * Any other file format than Fluent makes use of a converter. Read more about converters and their limitations here https://inlang.dev/architecture/overview#support-for-file-formats-other-than-fluent.
     */
    fileFormat: 'fluent' | 'localizable-strings';
    /**
     * Where and how the local translation files are saved.
     *
     * Use '{languageCode}' as dynamic value.
     * @examples
     * 		`./translations/{languageCode}.json`
     * 		.`/{languageCode}/Localizable.strings`
     */
    pathPattern: string;
    /**
     * A link to the pegjs grammar to detect the usage of i18n (translations) in the source code.
     *
     * Go to https://github.com/inlang/inlang/tree/main/packages/i18n-detection/src/grammars for predefined grammars.
     *
     * Using a link offers flexibility to define own grammars for specific environments. Go to
     */
    fetchI18nDetectionGrammarFrom?: string;
    /**
     * The replacement options when extracting pattern.
     *
     * Must include `{id}` in all options.
     * @example
     * 		['t("{id}")', 'i18n.{id}']
     */
    extractPatternReplacementOptions?: string[];
    /**
     * An ISO 639-1 human language code that determines the base language.
     */
    baseLanguageCode?: string;
    [k: string]: unknown;
}
